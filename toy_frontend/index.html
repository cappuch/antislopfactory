<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>antislopfactory</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0d1117;--surface:#161b22;--surface2:#21262d;--border:#30363d;
  --text:#e6edf3;--text2:#8b949e;--accent:#58a6ff;--red:#f85149;
  --green:#3fb950;--yellow:#d29922;--orange:#db6d28;
}
html,body{height:100%;font-family:'SF Mono','Cascadia Code','Consolas',monospace;
  font-size:13px;background:var(--bg);color:var(--text)}

/* layout */
.app{display:flex;height:100vh}
.sidebar{width:240px;background:var(--surface);border-right:1px solid var(--border);
  display:flex;flex-direction:column;flex-shrink:0}
.main{flex:1;display:flex;flex-direction:column;min-width:0}

/* sidebar */
.sidebar-header{padding:12px;border-bottom:1px solid var(--border);
  display:flex;align-items:center;justify-content:space-between}
.sidebar-header h2{font-size:14px;font-weight:600}
.btn-new{background:var(--accent);color:#000;border:none;padding:4px 10px;
  border-radius:4px;cursor:pointer;font-size:12px;font-family:inherit}
.btn-new:hover{opacity:.85}
.thread-list{flex:1;overflow-y:auto;padding:4px}
.thread-item{padding:8px 12px;border-radius:4px;cursor:pointer;
  margin-bottom:2px;font-size:12px;display:flex;justify-content:space-between;align-items:center}
.thread-item:hover{background:var(--surface2)}
.thread-item.active{background:var(--surface2);border-left:2px solid var(--accent)}
.thread-item .risk-badge{font-size:10px;padding:1px 5px;border-radius:8px;
  background:var(--green);color:#000;font-weight:600}
.thread-item .risk-badge.warn{background:var(--yellow)}
.thread-item .risk-badge.danger{background:var(--red)}
.thread-preview{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
  max-width:150px;color:var(--text2)}

/* top bar */
.topbar{padding:8px 16px;border-bottom:1px solid var(--border);
  display:flex;align-items:center;gap:12px;background:var(--surface);font-size:12px}
.topbar .thread-id{color:var(--text2);font-size:11px}
.topbar .model-name{color:var(--accent)}
.stream-stats{margin-left:auto;display:none;align-items:center;gap:10px;font-size:11px;color:var(--text2)}
.stream-stats.active{display:flex}
.stream-stats .live-dot{width:6px;height:6px;border-radius:50%;background:var(--red);
  animation:pulse 1s ease infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}
.stat{display:flex;align-items:center;gap:3px}
.stat .stat-val{color:var(--text);font-weight:600}

/* messages area */
.messages{flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:8px}
.msg-wrap{position:relative;max-width:85%;display:flex;flex-direction:column}
.msg-wrap.user{align-self:flex-end}
.msg-wrap.assistant{align-self:flex-start}
.msg-wrap.system{align-self:center}
.msg-wrap.tool-call{align-self:flex-start}
.msg-wrap.tool-result{align-self:flex-start}
.msg{padding:10px 14px;border-radius:8px;line-height:1.5;
  white-space:pre-wrap;word-break:break-word}
.msg.user{background:var(--accent);color:#000;border-bottom-right-radius:2px}
.msg.assistant{background:var(--surface2);border-bottom-left-radius:2px}
.msg.assistant.streaming{border-left:2px solid var(--accent)}
.msg.system{background:var(--surface);color:var(--text2);
  font-size:11px;font-style:italic;border-radius:4px}
.msg.tool-call{background:#1a1e2a;border:1px solid #2d4a7a;
  font-size:12px;border-bottom-left-radius:2px}
.msg.tool-result{background:#1a2a1e;border:1px solid #2d7a4a;
  font-size:12px;border-bottom-left-radius:2px}
.msg-label{font-size:10px;font-weight:600;text-transform:uppercase;
  margin-bottom:4px;opacity:.7}

/* info button + inline classification table */
.msg-info-btn{position:absolute;top:4px;right:4px;width:18px;height:18px;
  border-radius:50%;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.3);
  color:var(--text2);font-size:11px;cursor:pointer;display:flex;align-items:center;
  justify-content:center;opacity:0;transition:opacity .15s;z-index:1;line-height:1}
.msg-wrap:hover .msg-info-btn{opacity:1}
.msg-wrap.user .msg-info-btn{border-color:rgba(0,0,0,.3);background:rgba(0,0,0,.15);color:#000}
.msg-clf-table{font-size:10px;margin-top:6px;background:rgba(0,0,0,.2);
  border-radius:4px;padding:6px 8px;display:none}
.msg-clf-table.open{display:block}
.msg-clf-table .clf-row{display:flex;align-items:center;gap:6px;padding:1px 0}
.msg-clf-table .clf-row .clf-name{width:90px;text-align:right;color:var(--text2);
  overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.msg-clf-table .clf-row .clf-bar{flex:1;height:4px;background:rgba(255,255,255,.05);
  border-radius:2px;overflow:hidden}
.msg-clf-table .clf-row .clf-fill{height:100%;border-radius:2px}
.msg-clf-table .clf-row .clf-pct{width:36px;text-align:right;color:var(--text2)}
.msg-clf-table .clf-summary{margin-bottom:4px;font-weight:600}
.msg-clf-table .clf-summary.safe{color:var(--green)}
.msg-clf-table .clf-summary.unsafe{color:var(--red)}
.msg-wrap.user .msg-clf-table{background:rgba(0,0,0,.12);color:#000}
.msg-wrap.user .msg-clf-table .clf-row .clf-name{color:rgba(0,0,0,.6)}
.msg-wrap.user .msg-clf-table .clf-row .clf-pct{color:rgba(0,0,0,.6)}
.msg-wrap.user .msg-clf-table .clf-row .clf-bar{background:rgba(0,0,0,.1)}
.msg-wrap.user .msg-clf-table .clf-summary.safe{color:#1a6e2e}
.msg-wrap.user .msg-clf-table .clf-summary.unsafe{color:#b91c1c}

/* blinking cursor */
.cursor{display:inline;animation:blink .6s step-end infinite;color:var(--accent)}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0}}

/* classification panel */
.classification-panel{background:var(--surface);border-top:1px solid var(--border);
  padding:10px 16px;font-size:11px;transition:opacity .2s}
.clf-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.clf-label{font-weight:700;text-transform:uppercase;font-size:13px}
.clf-label.safe{color:var(--green)}
.clf-label.unsafe{color:var(--red)}
.clf-meta{display:flex;gap:12px;color:var(--text2)}
.prob-bars{display:flex;flex-wrap:wrap;gap:3px 12px}
.prob-bar{display:flex;align-items:center;gap:4px;width:calc(50% - 6px)}
.prob-bar .name{width:100px;text-align:right;color:var(--text2);overflow:hidden;
  text-overflow:ellipsis;white-space:nowrap;font-size:11px}
.prob-bar .bar{flex:1;height:8px;background:var(--bg);border-radius:4px;overflow:hidden}
.prob-bar .bar-fill{height:100%;border-radius:4px;transition:width .15s ease-out,background .15s}
.prob-bar .val{width:44px;font-size:10px;color:var(--text2);text-align:right;
  transition:color .15s}
.prob-bar .val.hot{color:var(--red);font-weight:600}

/* input area */
.input-area{padding:12px 16px;border-top:1px solid var(--border);
  display:flex;gap:8px;align-items:flex-end;background:var(--surface)}
.input-area textarea{flex:1;background:var(--surface2);color:var(--text);
  border:1px solid var(--border);border-radius:6px;padding:8px 12px;
  font-family:inherit;font-size:13px;resize:none;min-height:40px;max-height:120px}
.input-area textarea:focus{outline:none;border-color:var(--accent)}
.input-area button{background:var(--accent);color:#000;border:none;
  padding:8px 16px;border-radius:6px;cursor:pointer;font-family:inherit;
  font-weight:600;font-size:13px}
.input-area button:disabled{opacity:.4;cursor:not-allowed}

/* modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);
  display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--surface);border:1px solid var(--border);
  border-radius:8px;padding:20px;width:400px}
.modal h3{margin-bottom:12px;font-size:15px}
.modal textarea{width:100%;background:var(--surface2);color:var(--text);
  border:1px solid var(--border);border-radius:4px;padding:8px;
  font-family:inherit;font-size:13px;min-height:80px;resize:vertical}
.modal .actions{display:flex;gap:8px;margin-top:12px;justify-content:flex-end}
.modal .btn-cancel{background:var(--surface2);color:var(--text);border:1px solid var(--border);
  padding:6px 14px;border-radius:4px;cursor:pointer;font-family:inherit}
.modal .btn-create{background:var(--accent);color:#000;border:none;
  padding:6px 14px;border-radius:4px;cursor:pointer;font-family:inherit;font-weight:600}

/* tool status */
.tool-status{padding:4px 16px;background:#1a1e2a;border-top:1px solid #2d4a7a;
  font-size:11px;color:var(--accent);display:none;align-items:center;gap:6px}
.tool-status.active{display:flex}
.spinner{width:12px;height:12px;border:2px solid var(--accent);
  border-top-color:transparent;border-radius:50%;animation:spin .6s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* empty state */
.empty-state{flex:1;display:flex;align-items:center;justify-content:center;
  color:var(--text2);font-size:14px}

/* scrollbar */
::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--surface2);border-radius:3px}
</style>
</head>
<body>

<div class="app">
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>threads</h2>
      <button class="btn-new" onclick="showNewThreadModal()">+ new</button>
    </div>
    <div class="thread-list" id="threadList"></div>
  </div>

  <div class="main">
    <div class="topbar">
      <span class="model-name" id="modelName">antislopfactory</span>
      <span class="thread-id" id="threadIdDisplay">no thread selected</span>
      <div class="stream-stats" id="streamStats">
        <div class="live-dot"></div>
        <div class="stat">ttft: <span class="stat-val" id="statTtft">--</span></div>
        <div class="stat">tok/s: <span class="stat-val" id="statTokSec">--</span></div>
        <div class="stat">tokens: <span class="stat-val" id="statTokens">0</span></div>
        <div class="stat">chars: <span class="stat-val" id="statChars">0</span></div>
      </div>
    </div>

    <div class="messages" id="messages">
      <div class="empty-state">create or select a thread to start</div>
    </div>

    <div class="tool-status" id="toolStatus">
      <div class="spinner"></div>
      <span id="toolStatusText">executing tool...</span>
    </div>

    <div class="classification-panel" id="clfPanel" style="display:none">
      <div class="clf-header">
        <span class="clf-label" id="clfLabel">--</span>
        <div class="clf-meta">
          <span id="clfRisk">risk: --/10</span>
          <span id="clfChars"></span>
        </div>
      </div>
      <div class="prob-bars" id="probBars"></div>
    </div>

    <div class="input-area">
      <textarea id="msgInput" placeholder="send a message..." rows="1"
        onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendMessage()}"></textarea>
      <button id="sendBtn" onclick="sendMessage()">send</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="newThreadModal" style="display:none">
  <div class="modal">
    <h3>new thread</h3>
    <textarea id="systemPromptInput" placeholder="system prompt...">You are a helpful assistant. You have access to web search and a JavaScript sandbox. Use them when needed to answer questions accurately.</textarea>
    <div class="actions">
      <button class="btn-cancel" onclick="hideNewThreadModal()">cancel</button>
      <button class="btn-create" onclick="createThread()">create</button>
    </div>
  </div>
</div>

<iframe id="jsSandbox" sandbox="allow-scripts" style="display:none"></iframe>

<script>
const API = location.origin;

// ── state ──────────────────────────────────────────────────────────
let currentThreadId = null;
let isStreaming = false;

// keep track of prob-bar DOM nodes so we can update in place (no flicker)
let probBarEls = {};  // name -> {fill, val}

const TOOLS = [
  {
    type: "function",
    function: {
      name: "web_search",
      description: "Search the web using Google. Returns titles, URLs, and descriptions. Use for factual questions, current events, or when you need to look something up.",
      parameters: {
        type: "object",
        properties: { query: { type: "string", description: "The search query" } },
        required: ["query"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "javascript_sandbox",
      description: "Execute JavaScript code in a sandboxed environment. Console.log output and the final expression result are captured and returned.",
      parameters: {
        type: "object",
        properties: { code: { type: "string", description: "JavaScript code to execute" } },
        required: ["code"]
      }
    }
  }
];

const UNSAFE_LABELS = new Set([
  'violence','hate','harassment','sexual','self_harm','criminal',
  'malware','illegal','fraud','harmful','unethical','unsafe_other'
]);

// fixed ordering so bars don't jump around
const LABEL_ORDER = [
  'safe','criminal','deception','fraud','harassment','harmful','hate',
  'illegal','malware','privacy','professional_advice','self_harm',
  'sexual','unethical','unsafe_other','violence'
];

// ── thread management ──────────────────────────────────────────────
async function loadThreads() {
  const r = await fetch(`${API}/threads`);
  const data = await r.json();
  const list = document.getElementById('threadList');
  list.innerHTML = '';
  for (const t of data.threads) {
    const div = document.createElement('div');
    div.className = 'thread-item' + (t.thread_id === currentThreadId ? ' active' : '');
    const riskClass = t.risk >= 7 ? 'danger' : t.risk >= 4 ? 'warn' : '';
    div.innerHTML = `
      <span class="thread-preview">${t.first_user_message || 'empty thread'}</span>
      <span class="risk-badge ${riskClass}">${t.risk}</span>`;
    div.onclick = () => selectThread(t.thread_id);
    list.appendChild(div);
  }
}

function showNewThreadModal() {
  document.getElementById('newThreadModal').style.display = 'flex';
  document.getElementById('systemPromptInput').focus();
}
function hideNewThreadModal() {
  document.getElementById('newThreadModal').style.display = 'none';
}

async function createThread() {
  const prompt = document.getElementById('systemPromptInput').value.trim();
  if (!prompt) return;
  const r = await fetch(`${API}/threads`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ system_prompt: prompt })
  });
  const data = await r.json();
  hideNewThreadModal();
  await loadThreads();
  selectThread(data.thread_id);
}

async function selectThread(threadId) {
  currentThreadId = threadId;
  document.getElementById('threadIdDisplay').textContent = threadId;
  document.getElementById('clfPanel').style.display = 'none';
  await loadThreads();
  await loadMessages();
}

async function loadMessages() {
  if (!currentThreadId) return;
  const r = await fetch(`${API}/threads/${currentThreadId}/messages`);
  const data = await r.json();
  const container = document.getElementById('messages');
  container.innerHTML = '';
  for (const m of data.messages) {
    if (m.role === 'system') {
      addMessageBubble('system', m.content);
    } else if (m.role === 'user') {
      addMessageBubble('user', m.content, m.metadata?.classification);
    } else if (m.role === 'assistant') {
      if (m.metadata?.tool_calls) {
        for (const tc of m.metadata.tool_calls) addToolCallBubble(tc);
      }
      if (m.content) addMessageBubble('assistant', m.content, m.metadata?.classification);
      if (m.metadata?.classification) {
        updateClassification({
          label: m.metadata.classification.label,
          probabilities: m.metadata.classification.probabilities,
          risk: m.metadata.classification.risk ?? 0,
          content_length: 0, final: true
        });
      }
    } else if (m.role === 'tool') {
      addToolResultBubble(m.metadata?.tool_call_id || '??', m.content, m.metadata?.classification);
    }
  }
  container.scrollTop = container.scrollHeight;
}

// ── message display ────────────────────────────────────────────────
function buildClfTable(clf) {
  const table = document.createElement('div');
  table.className = 'msg-clf-table';
  const isUnsafe = UNSAFE_LABELS.has(clf.label);
  const risk = clf.risk ?? _computeRisk(clf.probabilities);
  table.innerHTML = `<div class="clf-summary ${isUnsafe ? 'unsafe' : 'safe'}">${esc(clf.label)} &middot; risk ${risk}/10</div>`;
  const sorted = LABEL_ORDER
    .map(name => [name, clf.probabilities[name] ?? 0])
    .sort((a, b) => b[1] - a[1]);
  for (const [name, prob] of sorted) {
    const pct = (prob * 100).toFixed(1);
    const unsafe = UNSAFE_LABELS.has(name);
    const color = unsafe ? `hsl(${Math.max(0, 120 - prob * 400)}, 80%, 50%)` : 'var(--green)';
    const row = document.createElement('div');
    row.className = 'clf-row';
    row.innerHTML = `<span class="clf-name">${esc(name)}</span><div class="clf-bar"><div class="clf-fill" style="width:${pct}%;background:${color}"></div></div><span class="clf-pct">${pct}%</span>`;
    table.appendChild(row);
  }
  return table;
}

function _computeRisk(probs) {
  let sum = 0;
  for (const l of UNSAFE_LABELS) sum += probs[l] ?? 0;
  return Math.min(10, Math.floor(sum * 10));
}

function addMessageBubble(role, text, classification) {
  const container = document.getElementById('messages');
  const wrap = document.createElement('div');
  wrap.className = `msg-wrap ${role}`;
  const el = document.createElement('div');
  el.className = `msg ${role}`;
  el.textContent = text;
  wrap.appendChild(el);

  if ((role === 'user' || role === 'assistant') && classification) {
    attachClfToWrap(wrap, classification);
  }

  container.appendChild(wrap);
  container.scrollTop = container.scrollHeight;
  return el;
}

function attachClfToWrap(wrap, clf) {
  const btn = document.createElement('button');
  btn.className = 'msg-info-btn';
  btn.textContent = 'i';
  const table = buildClfTable(clf);
  btn.onclick = (e) => { e.stopPropagation(); table.classList.toggle('open'); };
  wrap.appendChild(btn);
  wrap.appendChild(table);
}

// fire-and-forget: classify text via /classify endpoint and attach result
function classifyAndAttach(wrap, text) {
  if (!text || !text.trim()) return;
  fetch(`${API}/classify`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: text.slice(0, 2000) })
  }).then(r => r.json()).then(data => {
    if (data.results?.[0]) {
      attachClfToWrap(wrap, data.results[0]);
    }
  }).catch(() => {});
}

function addToolCallBubble(tc, classification) {
  const container = document.getElementById('messages');
  const wrap = document.createElement('div');
  wrap.className = 'msg-wrap tool-call';
  const el = document.createElement('div');
  el.className = 'msg tool-call';
  let args = tc.function.arguments;
  try { args = JSON.stringify(JSON.parse(args), null, 2); } catch {}
  el.innerHTML = `<div class="msg-label">tool call: ${esc(tc.function.name)}</div>${esc(args)}`;
  wrap.appendChild(el);
  container.appendChild(wrap);
  container.scrollTop = container.scrollHeight;
  // classify the tool call arguments
  if (classification) {
    attachClfToWrap(wrap, classification);
  } else {
    classifyAndAttach(wrap, args);
  }
}

function addToolResultBubble(callId, content, classification) {
  const container = document.getElementById('messages');
  const wrap = document.createElement('div');
  wrap.className = 'msg-wrap tool-result';
  const el = document.createElement('div');
  el.className = 'msg tool-result';
  const preview = content.length > 500 ? content.slice(0, 500) + '...' : content;
  el.innerHTML = `<div class="msg-label">tool result</div>${esc(preview)}`;
  wrap.appendChild(el);
  container.appendChild(wrap);
  container.scrollTop = container.scrollHeight;
  // classify the tool result content
  if (classification) {
    attachClfToWrap(wrap, classification);
  } else {
    classifyAndAttach(wrap, content);
  }
}

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ── classification display ─────────────────────────────────────────
function initProbBars() {
  const bars = document.getElementById('probBars');
  bars.innerHTML = '';
  probBarEls = {};
  for (const name of LABEL_ORDER) {
    const row = document.createElement('div');
    row.className = 'prob-bar';
    const nameSpan = document.createElement('span');
    nameSpan.className = 'name';
    nameSpan.textContent = name;
    const barOuter = document.createElement('div');
    barOuter.className = 'bar';
    const fill = document.createElement('div');
    fill.className = 'bar-fill';
    fill.style.width = '0%';
    fill.style.background = 'var(--green)';
    barOuter.appendChild(fill);
    const val = document.createElement('span');
    val.className = 'val';
    val.textContent = '0.0%';
    row.appendChild(nameSpan);
    row.appendChild(barOuter);
    row.appendChild(val);
    bars.appendChild(row);
    probBarEls[name] = { fill, val };
  }
}

function updateClassification(clf) {
  const panel = document.getElementById('clfPanel');
  panel.style.display = '';
  const labelEl = document.getElementById('clfLabel');
  labelEl.textContent = clf.label;
  labelEl.className = 'clf-label ' + (UNSAFE_LABELS.has(clf.label) ? 'unsafe' : 'safe');
  document.getElementById('clfRisk').textContent = `risk: ${clf.risk}/10`;
  if (clf.content_length) {
    document.getElementById('clfChars').textContent = `@ ${clf.content_length} chars`;
  }

  // init bars on first classification
  if (!Object.keys(probBarEls).length) initProbBars();

  // update each bar in place — no DOM rebuild, smooth transitions
  for (const name of LABEL_ORDER) {
    const prob = clf.probabilities[name] ?? 0;
    const pct = (prob * 100).toFixed(1);
    const el = probBarEls[name];
    if (!el) continue;
    const isUnsafe = UNSAFE_LABELS.has(name);
    const color = isUnsafe
      ? `hsl(${Math.max(0, 120 - prob * 400)}, 80%, 50%)`
      : 'var(--green)';
    el.fill.style.width = pct + '%';
    el.fill.style.background = color;
    el.val.textContent = pct + '%';
    el.val.className = prob > 0.1 && isUnsafe ? 'val hot' : 'val';
  }
}

// ── tool execution ─────────────────────────────────────────────────
async function executeWebSearch(query) {
  try {
    const r = await fetch(`${API}/search?q=${encodeURIComponent(query)}`);
    const data = await r.json();
    if (!data.results?.length) return 'No results found for this query.';
    let out = '';
    for (const item of data.results) {
      out += `${item.title}\n${item.url}\n${item.description}\n\n`;
    }
    return out.trim();
  } catch (e) {
    return `Search error: ${e.message}`;
  }
}

function executeJsSandbox(code) {
  return new Promise((resolve) => {
    const iframe = document.getElementById('jsSandbox');
    const timeout = setTimeout(() => {
      window.removeEventListener('message', handler);
      resolve('Error: execution timed out (5s)');
    }, 5000);

    function handler(e) {
      if (e.source === iframe.contentWindow) {
        window.removeEventListener('message', handler);
        clearTimeout(timeout);
        const d = e.data;
        let out = '';
        if (d.logs?.length) out += 'Console output:\n' + d.logs.join('\n') + '\n';
        if (d.error) out += `Error: ${d.error}\n`;
        else if (d.result !== undefined && d.result !== 'undefined') out += `Result: ${d.result}\n`;
        resolve(out || '(no output)');
      }
    }
    window.addEventListener('message', handler);

    iframe.srcdoc = `<script>
      const logs = [];
      console.log = (...a) => logs.push(a.map(String).join(' '));
      console.error = console.log;
      console.warn = console.log;
      try {
        const __result = (function(){${code}})();
        parent.postMessage({result: String(__result), logs}, '*');
      } catch(e) {
        parent.postMessage({error: e.message, logs}, '*');
      }
    <\/script>`;
  });
}

async function executeTool(name, argsStr) {
  let args;
  try { args = JSON.parse(argsStr); } catch { args = {}; }
  if (name === 'web_search') return await executeWebSearch(args.query || '');
  if (name === 'javascript_sandbox') return await executeJsSandbox(args.code || '');
  return `Unknown tool: ${name}`;
}

// ── streaming chat ─────────────────────────────────────────────────
async function sendMessage() {
  if (!currentThreadId || isStreaming) return;
  const input = document.getElementById('msgInput');
  const text = input.value.trim();
  if (!text) return;
  input.value = '';
  input.style.height = 'auto';
  addMessageBubble('user', text);
  await streamChat(text);
}

async function streamChat(message) {
  isStreaming = true;
  document.getElementById('sendBtn').disabled = true;

  // show live stats
  const statsEl = document.getElementById('streamStats');
  const statTtft = document.getElementById('statTtft');
  const statTokSec = document.getElementById('statTokSec');
  const statTokens = document.getElementById('statTokens');
  const statChars = document.getElementById('statChars');
  statsEl.classList.add('active');
  statTtft.textContent = '--';
  statTokSec.textContent = '--';
  statTokens.textContent = '0';
  statChars.textContent = '0';
  let tokenCount = 0;
  let chunkCount = 0;
  let ttft = null;  // time to first token (ms)
  let firstTokenTime = null;
  const streamStart = performance.now();

  // show classification panel immediately with zeroed bars
  document.getElementById('clfPanel').style.display = '';
  document.getElementById('clfLabel').textContent = 'waiting...';
  document.getElementById('clfLabel').className = 'clf-label';
  document.getElementById('clfRisk').textContent = 'risk: --/10';
  document.getElementById('clfChars').textContent = '';
  initProbBars();

  const body = { tools: TOOLS, stream: true };
  if (message !== null) body.message = message;

  const resp = await fetch(`${API}/threads/${currentThreadId}/chat`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
    body: JSON.stringify(body)
  });

  const messagesEl = document.getElementById('messages');
  let contentWrap = null;   // msg-wrap div
  let contentBubble = null; // msg div inside wrap
  let contentText = '';
  let reasoningText = '';
  let toolCalls = {};
  let lastClf = null;  // last classification from stream, for inline table
  let cursorEl = null;

  function ensureBubble() {
    if (!contentBubble) {
      contentWrap = document.createElement('div');
      contentWrap.className = 'msg-wrap assistant';
      contentBubble = document.createElement('div');
      contentBubble.className = 'msg assistant streaming';
      cursorEl = document.createElement('span');
      cursorEl.className = 'cursor';
      cursorEl.textContent = '\u2588';
      contentBubble.appendChild(cursorEl);
      contentWrap.appendChild(contentBubble);
      messagesEl.appendChild(contentWrap);
    }
  }

  function updateBubble() {
    ensureBubble();
    contentBubble.textContent = contentText;
    contentBubble.appendChild(cursorEl);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  function updateStats() {
    statTokens.textContent = tokenCount;
    statChars.textContent = contentText.length;
    if (ttft !== null) {
      statTtft.textContent = ttft + 'ms';
      // tok/s measured from first token (excludes TTFT wait)
      const sinceFirst = (performance.now() - firstTokenTime) / 1000;
      statTokSec.textContent = sinceFirst > 0.05 ? (tokenCount / sinceFirst).toFixed(1) : '--';
    }
  }

  function processEvent(block) {
    let eventType = null;
    const dataLines = [];
    for (const line of block.split('\n')) {
      if (line.startsWith('event:')) eventType = line.slice(6).trim();
      else if (line.startsWith('data:')) dataLines.push(line.slice(5).trim());
    }
    for (const raw of dataLines) {
      if (raw === '[DONE]') continue;
      let obj;
      try { obj = JSON.parse(raw); } catch { continue; }

      if (eventType === 'classification') {
        lastClf = obj;
        updateClassification(obj);
        continue;
      }

      for (const choice of obj.choices || []) {
        const delta = choice.delta || {};

        if (typeof delta.content === 'string' && delta.content) {
          if (ttft === null) {
            ttft = Math.round(performance.now() - streamStart);
            firstTokenTime = performance.now();
          }
          chunkCount++;
          tokenCount++;
          contentText += delta.content;
          updateBubble();
          updateStats();
        }

        if (typeof delta.reasoning_content === 'string' && delta.reasoning_content) {
          reasoningText += delta.reasoning_content;
        }

        if (delta.tool_calls) {
          for (const tc of delta.tool_calls) {
            const i = tc.index ?? 0;
            if (!toolCalls[i]) toolCalls[i] = { id: '', name: '', arguments: '' };
            if (tc.id) toolCalls[i].id = tc.id;
            if (tc.function?.name) toolCalls[i].name = tc.function.name;
            if (tc.function?.arguments) toolCalls[i].arguments += tc.function.arguments;
          }
          chunkCount++;
          updateStats();
        }
      }
    }
  }

  // read stream
  const reader = resp.body.getReader();
  const decoder = new TextDecoder();
  let buf = '';

  for (;;) {
    const { done, value } = await reader.read();
    if (done) break;
    buf += decoder.decode(value, { stream: true });
    let sep;
    while ((sep = buf.indexOf('\n\n')) !== -1) {
      const block = buf.slice(0, sep);
      buf = buf.slice(sep + 2);
      if (block.trim()) processEvent(block);
    }
  }
  if (buf.trim()) processEvent(buf);

  // stream done — remove cursor, attach inline classification
  if (contentBubble) {
    if (cursorEl && cursorEl.parentNode) cursorEl.remove();
    contentBubble.classList.remove('streaming');
    if (lastClf && contentWrap) attachClfToWrap(contentWrap, lastClf);
  }
  statsEl.classList.remove('active');

  const tcList = Object.values(toolCalls);
  if (tcList.length > 0 && tcList[0].id) {
    await handleToolCalls(tcList);
  } else {
    isStreaming = false;
    document.getElementById('sendBtn').disabled = false;
    // reload to pick up user message classification
    await loadThreads();
  }
}

async function handleToolCalls(toolCallsList) {
  for (const tc of toolCallsList) {
    addToolCallBubble({ function: { name: tc.name, arguments: tc.arguments } });
  }

  const toolStatusEl = document.getElementById('toolStatus');
  const toolStatusText = document.getElementById('toolStatusText');
  toolStatusEl.classList.add('active');

  const results = [];
  for (const tc of toolCallsList) {
    toolStatusText.textContent = `executing ${tc.name}...`;
    const output = await executeTool(tc.name, tc.arguments);
    results.push({ tool_call_id: tc.id, content: output });
    addToolResultBubble(tc.id, output);
  }

  toolStatusText.textContent = 'submitting results...';
  await fetch(`${API}/threads/${currentThreadId}/tool_results`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tool_results: results })
  });

  toolStatusEl.classList.remove('active');
  await streamChat(null);
}

// ── textarea auto-resize ───────────────────────────────────────────
document.getElementById('msgInput').addEventListener('input', function() {
  this.style.height = 'auto';
  this.style.height = Math.min(this.scrollHeight, 120) + 'px';
});

// ── init ───────────────────────────────────────────────────────────
loadThreads();
</script>
</body>
</html>
