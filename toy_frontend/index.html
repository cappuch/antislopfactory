<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>antislopfactory</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0d1117;--surface:#161b22;--surface2:#21262d;--border:#30363d;
  --text:#e6edf3;--text2:#8b949e;--accent:#58a6ff;--red:#f85149;
  --green:#3fb950;--yellow:#d29922;--orange:#db6d28;
}
html,body{height:100%;font-family:'SF Mono','Cascadia Code','Consolas',monospace;
  font-size:13px;background:var(--bg);color:var(--text)}

/* layout */
.app{display:flex;height:100vh}
.sidebar{width:240px;background:var(--surface);border-right:1px solid var(--border);
  display:flex;flex-direction:column;flex-shrink:0}
.main{flex:1;display:flex;flex-direction:column;min-width:0}

/* sidebar */
.sidebar-header{padding:12px;border-bottom:1px solid var(--border);
  display:flex;align-items:center;justify-content:space-between}
.sidebar-header h2{font-size:14px;font-weight:600}
.btn-new{background:var(--accent);color:#000;border:none;padding:4px 10px;
  border-radius:4px;cursor:pointer;font-size:12px;font-family:inherit}
.btn-new:hover{opacity:.85}
.thread-list{flex:1;overflow-y:auto;padding:4px}
.thread-item{padding:8px 12px;border-radius:4px;cursor:pointer;
  margin-bottom:2px;font-size:12px;display:flex;justify-content:space-between;align-items:center}
.thread-item:hover{background:var(--surface2)}
.thread-item.active{background:var(--surface2);border-left:2px solid var(--accent)}
.thread-item .risk-badge{font-size:10px;padding:1px 5px;border-radius:8px;
  background:var(--green);color:#000;font-weight:600}
.thread-item .risk-badge.warn{background:var(--yellow)}
.thread-item .risk-badge.danger{background:var(--red)}
.thread-preview{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
  max-width:150px;color:var(--text2)}

/* top bar */
.topbar{padding:8px 16px;border-bottom:1px solid var(--border);
  display:flex;align-items:center;gap:12px;background:var(--surface);font-size:12px}
.topbar .thread-id{color:var(--text2);font-size:11px}
.topbar .model-name{color:var(--accent)}

/* messages area */
.messages{flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:8px}
.msg{max-width:85%;padding:10px 14px;border-radius:8px;line-height:1.5;
  white-space:pre-wrap;word-break:break-word}
.msg.user{background:var(--accent);color:#000;align-self:flex-end;border-bottom-right-radius:2px}
.msg.assistant{background:var(--surface2);align-self:flex-start;border-bottom-left-radius:2px}
.msg.system{background:var(--surface);color:var(--text2);align-self:center;
  font-size:11px;font-style:italic;border-radius:4px}
.msg.tool-call{background:#1a1e2a;border:1px solid #2d4a7a;align-self:flex-start;
  font-size:12px;border-bottom-left-radius:2px}
.msg.tool-result{background:#1a2a1e;border:1px solid #2d7a4a;align-self:flex-start;
  font-size:12px;border-bottom-left-radius:2px}
.msg-label{font-size:10px;font-weight:600;text-transform:uppercase;
  margin-bottom:4px;opacity:.7}
.msg .reasoning{color:var(--text2);font-size:11px;font-style:italic;
  border-left:2px solid var(--border);padding-left:8px;margin-bottom:6px}

/* classification panel */
.classification-panel{background:var(--surface);border-top:1px solid var(--border);
  padding:10px 16px;font-size:11px}
.clf-header{display:flex;justify-content:space-between;margin-bottom:6px}
.clf-label{font-weight:700;text-transform:uppercase}
.clf-label.safe{color:var(--green)}
.clf-label.unsafe{color:var(--red)}
.clf-risk{color:var(--text2)}
.prob-bars{display:flex;flex-wrap:wrap;gap:3px 12px}
.prob-bar{display:flex;align-items:center;gap:4px;width:calc(50% - 6px)}
.prob-bar .name{width:100px;text-align:right;color:var(--text2);overflow:hidden;
  text-overflow:ellipsis;white-space:nowrap}
.prob-bar .bar{flex:1;height:6px;background:var(--surface2);border-radius:3px;overflow:hidden}
.prob-bar .bar-fill{height:100%;border-radius:3px;transition:width .3s}
.prob-bar .val{width:40px;font-size:10px;color:var(--text2)}

/* input area */
.input-area{padding:12px 16px;border-top:1px solid var(--border);
  display:flex;gap:8px;align-items:flex-end;background:var(--surface)}
.input-area textarea{flex:1;background:var(--surface2);color:var(--text);
  border:1px solid var(--border);border-radius:6px;padding:8px 12px;
  font-family:inherit;font-size:13px;resize:none;min-height:40px;max-height:120px}
.input-area textarea:focus{outline:none;border-color:var(--accent)}
.input-area button{background:var(--accent);color:#000;border:none;
  padding:8px 16px;border-radius:6px;cursor:pointer;font-family:inherit;
  font-weight:600;font-size:13px}
.input-area button:disabled{opacity:.4;cursor:not-allowed}

/* modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);
  display:flex;align-items:center;justify-content:center;z-index:100}
.modal{background:var(--surface);border:1px solid var(--border);
  border-radius:8px;padding:20px;width:400px}
.modal h3{margin-bottom:12px;font-size:15px}
.modal textarea{width:100%;background:var(--surface2);color:var(--text);
  border:1px solid var(--border);border-radius:4px;padding:8px;
  font-family:inherit;font-size:13px;min-height:80px;resize:vertical}
.modal .actions{display:flex;gap:8px;margin-top:12px;justify-content:flex-end}
.modal .btn-cancel{background:var(--surface2);color:var(--text);border:1px solid var(--border);
  padding:6px 14px;border-radius:4px;cursor:pointer;font-family:inherit}
.modal .btn-create{background:var(--accent);color:#000;border:none;
  padding:6px 14px;border-radius:4px;cursor:pointer;font-family:inherit;font-weight:600}

/* tool status */
.tool-status{padding:4px 16px;background:#1a1e2a;border-top:1px solid #2d4a7a;
  font-size:11px;color:var(--accent);display:none;align-items:center;gap:6px}
.tool-status.active{display:flex}
.spinner{width:12px;height:12px;border:2px solid var(--accent);
  border-top-color:transparent;border-radius:50%;animation:spin .6s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* empty state */
.empty-state{flex:1;display:flex;align-items:center;justify-content:center;
  color:var(--text2);font-size:14px}

/* scrollbar */
::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--surface2);border-radius:3px}
</style>
</head>
<body>

<div class="app">
  <div class="sidebar">
    <div class="sidebar-header">
      <h2>threads</h2>
      <button class="btn-new" onclick="showNewThreadModal()">+ new</button>
    </div>
    <div class="thread-list" id="threadList"></div>
  </div>

  <div class="main">
    <div class="topbar">
      <span class="model-name" id="modelName">antislopfactory</span>
      <span class="thread-id" id="threadIdDisplay">no thread selected</span>
    </div>

    <div class="messages" id="messages">
      <div class="empty-state">create or select a thread to start</div>
    </div>

    <div class="tool-status" id="toolStatus">
      <div class="spinner"></div>
      <span id="toolStatusText">executing tool...</span>
    </div>

    <div class="classification-panel" id="clfPanel" style="display:none">
      <div class="clf-header">
        <span class="clf-label" id="clfLabel">--</span>
        <span class="clf-risk" id="clfRisk">risk: --/10</span>
      </div>
      <div class="prob-bars" id="probBars"></div>
    </div>

    <div class="input-area">
      <textarea id="msgInput" placeholder="send a message..." rows="1"
        onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendMessage()}"></textarea>
      <button id="sendBtn" onclick="sendMessage()">send</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="newThreadModal" style="display:none">
  <div class="modal">
    <h3>new thread</h3>
    <textarea id="systemPromptInput" placeholder="system prompt...">You are a helpful assistant. You have access to web search and a JavaScript sandbox. Use them when needed to answer questions accurately.</textarea>
    <div class="actions">
      <button class="btn-cancel" onclick="hideNewThreadModal()">cancel</button>
      <button class="btn-create" onclick="createThread()">create</button>
    </div>
  </div>
</div>

<!-- sandboxed iframe for JS execution -->
<iframe id="jsSandbox" sandbox="allow-scripts" style="display:none"></iframe>

<script>
const API = location.origin;  // same origin as backend

// ── state ──────────────────────────────────────────────────────────
let currentThreadId = null;
let isStreaming = false;

const TOOLS = [
  {
    type: "function",
    function: {
      name: "web_search",
      description: "Search the web using DuckDuckGo. Returns instant answer summaries and related topics. Use this for factual questions, current events, or when you need to look something up.",
      parameters: {
        type: "object",
        properties: {
          query: { type: "string", description: "The search query" }
        },
        required: ["query"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "javascript_sandbox",
      description: "Execute JavaScript code in a sandboxed environment. Use this for calculations, data processing, generating examples, or any task that benefits from running code. Console.log output and the final expression result are captured and returned.",
      parameters: {
        type: "object",
        properties: {
          code: { type: "string", description: "JavaScript code to execute" }
        },
        required: ["code"]
      }
    }
  }
];

// ── thread management ──────────────────────────────────────────────
async function loadThreads() {
  const r = await fetch(`${API}/threads`);
  const data = await r.json();
  const list = document.getElementById('threadList');
  list.innerHTML = '';
  for (const t of data.threads) {
    const div = document.createElement('div');
    div.className = 'thread-item' + (t.thread_id === currentThreadId ? ' active' : '');
    const riskClass = t.risk >= 7 ? 'danger' : t.risk >= 4 ? 'warn' : '';
    div.innerHTML = `
      <span class="thread-preview">${t.first_user_message || 'empty thread'}</span>
      <span class="risk-badge ${riskClass}">${t.risk}</span>`;
    div.onclick = () => selectThread(t.thread_id);
    list.appendChild(div);
  }
}

function showNewThreadModal() {
  document.getElementById('newThreadModal').style.display = 'flex';
  document.getElementById('systemPromptInput').focus();
}
function hideNewThreadModal() {
  document.getElementById('newThreadModal').style.display = 'none';
}

async function createThread() {
  const prompt = document.getElementById('systemPromptInput').value.trim();
  if (!prompt) return;
  const r = await fetch(`${API}/threads`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ system_prompt: prompt })
  });
  const data = await r.json();
  hideNewThreadModal();
  await loadThreads();
  selectThread(data.thread_id);
}

async function selectThread(threadId) {
  currentThreadId = threadId;
  document.getElementById('threadIdDisplay').textContent = threadId;
  document.getElementById('clfPanel').style.display = 'none';
  await loadThreads();
  await loadMessages();
}

async function loadMessages() {
  if (!currentThreadId) return;
  const r = await fetch(`${API}/threads/${currentThreadId}/messages`);
  const data = await r.json();
  const container = document.getElementById('messages');
  container.innerHTML = '';
  for (const m of data.messages) {
    if (m.role === 'system') {
      addMessageBubble('system', m.content);
    } else if (m.role === 'user') {
      addMessageBubble('user', m.content);
    } else if (m.role === 'assistant') {
      let text = '';
      if (m.reasoning_content) text += m.reasoning_content + '\n\n';
      text += m.content;
      // show tool calls if present
      if (m.metadata?.tool_calls) {
        for (const tc of m.metadata.tool_calls) {
          addToolCallBubble(tc);
        }
      }
      if (m.content) addMessageBubble('assistant', text);
      // show classification
      if (m.metadata?.classification) {
        updateClassification({
          label: m.metadata.classification.label,
          probabilities: m.metadata.classification.probabilities,
          risk: m.metadata.classification.risk ?? 0,
          final: true
        });
      }
    } else if (m.role === 'tool') {
      addToolResultBubble(m.metadata?.tool_call_id || '??', m.content);
    }
  }
  container.scrollTop = container.scrollHeight;
}

// ── message display ────────────────────────────────────────────────
function addMessageBubble(role, text) {
  const container = document.getElementById('messages');
  const el = document.createElement('div');
  el.className = `msg ${role}`;
  el.textContent = text;
  container.appendChild(el);
  container.scrollTop = container.scrollHeight;
  return el;
}

function addToolCallBubble(tc) {
  const container = document.getElementById('messages');
  const el = document.createElement('div');
  el.className = 'msg tool-call';
  let args = tc.function.arguments;
  try { args = JSON.stringify(JSON.parse(args), null, 2); } catch {}
  el.innerHTML = `<div class="msg-label">tool call: ${esc(tc.function.name)}</div>${esc(args)}`;
  container.appendChild(el);
  container.scrollTop = container.scrollHeight;
}

function addToolResultBubble(callId, content) {
  const container = document.getElementById('messages');
  const el = document.createElement('div');
  el.className = 'msg tool-result';
  const preview = content.length > 500 ? content.slice(0, 500) + '...' : content;
  el.innerHTML = `<div class="msg-label">tool result</div>${esc(preview)}`;
  container.appendChild(el);
  container.scrollTop = container.scrollHeight;
}

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ── classification display ─────────────────────────────────────────
const UNSAFE_LABELS = new Set([
  'violence','hate','harassment','sexual','self_harm','criminal',
  'malware','illegal','fraud','harmful','unethical','unsafe_other'
]);

function updateClassification(clf) {
  const panel = document.getElementById('clfPanel');
  panel.style.display = '';
  const labelEl = document.getElementById('clfLabel');
  labelEl.textContent = clf.label;
  labelEl.className = 'clf-label ' + (UNSAFE_LABELS.has(clf.label) ? 'unsafe' : 'safe');
  document.getElementById('clfRisk').textContent = `risk: ${clf.risk}/10`;

  const bars = document.getElementById('probBars');
  bars.innerHTML = '';
  // sort by probability descending
  const sorted = Object.entries(clf.probabilities).sort((a, b) => b[1] - a[1]);
  for (const [name, prob] of sorted) {
    const pct = (prob * 100).toFixed(1);
    const color = UNSAFE_LABELS.has(name)
      ? `hsl(${Math.max(0, 120 - prob * 400)}, 80%, 50%)`
      : 'var(--green)';
    bars.innerHTML += `
      <div class="prob-bar">
        <span class="name">${esc(name)}</span>
        <div class="bar"><div class="bar-fill" style="width:${pct}%;background:${color}"></div></div>
        <span class="val">${pct}%</span>
      </div>`;
  }
}

// ── tool execution ─────────────────────────────────────────────────
async function executeWebSearch(query) {
  try {
    const r = await fetch(`${API}/ddg?q=${encodeURIComponent(query)}`);
    const data = await r.json();
    let result = '';
    if (data.AbstractText) {
      result += `Summary: ${data.AbstractText}\n`;
      if (data.AbstractURL) result += `Source: ${data.AbstractURL}\n`;
    }
    if (data.Answer) result += `Answer: ${data.Answer}\n`;
    if (data.RelatedTopics?.length) {
      result += '\nRelated:\n';
      for (const t of data.RelatedTopics.slice(0, 8)) {
        if (t.Text) result += `- ${t.Text}\n`;
        if (t.Topics) {
          for (const sub of t.Topics.slice(0, 3)) {
            if (sub.Text) result += `  - ${sub.Text}\n`;
          }
        }
      }
    }
    return result || 'No results found for this query.';
  } catch (e) {
    return `Search error: ${e.message}`;
  }
}

function executeJsSandbox(code) {
  return new Promise((resolve) => {
    const iframe = document.getElementById('jsSandbox');
    const timeout = setTimeout(() => {
      window.removeEventListener('message', handler);
      resolve('Error: execution timed out (5s)');
    }, 5000);

    function handler(e) {
      if (e.source === iframe.contentWindow) {
        window.removeEventListener('message', handler);
        clearTimeout(timeout);
        const d = e.data;
        let out = '';
        if (d.logs?.length) out += 'Console output:\n' + d.logs.join('\n') + '\n';
        if (d.error) out += `Error: ${d.error}\n`;
        else if (d.result !== undefined && d.result !== 'undefined') out += `Result: ${d.result}\n`;
        resolve(out || '(no output)');
      }
    }
    window.addEventListener('message', handler);

    iframe.srcdoc = `<script>
      const logs = [];
      console.log = (...a) => logs.push(a.map(String).join(' '));
      console.error = console.log;
      console.warn = console.log;
      try {
        const __result = (function(){${code}})();
        parent.postMessage({result: String(__result), logs}, '*');
      } catch(e) {
        parent.postMessage({error: e.message, logs}, '*');
      }
    <\/script>`;
  });
}

async function executeTool(name, argsStr) {
  let args;
  try { args = JSON.parse(argsStr); } catch { args = {}; }

  if (name === 'web_search') {
    return await executeWebSearch(args.query || '');
  } else if (name === 'javascript_sandbox') {
    return await executeJsSandbox(args.code || '');
  }
  return `Unknown tool: ${name}`;
}

// ── streaming chat ─────────────────────────────────────────────────
async function sendMessage() {
  if (!currentThreadId || isStreaming) return;
  const input = document.getElementById('msgInput');
  const text = input.value.trim();
  if (!text) return;
  input.value = '';
  input.style.height = 'auto';

  addMessageBubble('user', text);
  await streamChat(text);
}

async function streamChat(message) {
  isStreaming = true;
  document.getElementById('sendBtn').disabled = true;

  const body = { tools: TOOLS, stream: true };
  if (message !== null) body.message = message;

  const resp = await fetch(`${API}/threads/${currentThreadId}/chat`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });

  const reader = resp.body.getReader();
  const decoder = new TextDecoder();
  let buf = '';
  let contentBubble = null;
  let contentText = '';
  let reasoningText = '';
  // accumulate tool_calls from deltas
  let toolCalls = {};  // index -> {id, name, arguments}

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buf += decoder.decode(value, { stream: true });

    // process complete SSE events
    let idx;
    while ((idx = buf.indexOf('\n\n')) !== -1) {
      const block = buf.slice(0, idx);
      buf = buf.slice(idx + 2);

      let eventType = null;
      const dataLines = [];
      for (const line of block.split('\n')) {
        if (line.startsWith('event:')) eventType = line.slice(6).trim();
        else if (line.startsWith('data:')) dataLines.push(line.slice(5).trim());
      }

      for (const data of dataLines) {
        if (data === '[DONE]') continue;
        let obj;
        try { obj = JSON.parse(data); } catch { continue; }

        if (eventType === 'classification') {
          updateClassification(obj);
          continue;
        }

        // standard chat completion chunk
        for (const choice of obj.choices || []) {
          const delta = choice.delta || {};

          // content
          if (typeof delta.content === 'string' && delta.content) {
            contentText += delta.content;
            if (!contentBubble) {
              contentBubble = addMessageBubble('assistant', '');
            }
            contentBubble.textContent = contentText;
            document.getElementById('messages').scrollTop =
              document.getElementById('messages').scrollHeight;
          }

          // reasoning
          if (typeof delta.reasoning_content === 'string' && delta.reasoning_content) {
            reasoningText += delta.reasoning_content;
          }

          // tool_calls
          if (delta.tool_calls) {
            for (const tc of delta.tool_calls) {
              const i = tc.index ?? 0;
              if (!toolCalls[i]) {
                toolCalls[i] = { id: '', name: '', arguments: '' };
              }
              if (tc.id) toolCalls[i].id = tc.id;
              if (tc.function?.name) toolCalls[i].name = tc.function.name;
              if (tc.function?.arguments) toolCalls[i].arguments += tc.function.arguments;
            }
          }
        }
      }
    }
  }

  // handle tool calls if any
  const tcList = Object.values(toolCalls);
  if (tcList.length > 0 && tcList[0].id) {
    await handleToolCalls(tcList);
  } else {
    isStreaming = false;
    document.getElementById('sendBtn').disabled = false;
    await loadThreads();
  }
}

async function handleToolCalls(toolCallsList) {
  // display tool calls
  for (const tc of toolCallsList) {
    addToolCallBubble({
      function: { name: tc.name, arguments: tc.arguments }
    });
  }

  // execute tools
  const toolStatusEl = document.getElementById('toolStatus');
  const toolStatusText = document.getElementById('toolStatusText');
  toolStatusEl.classList.add('active');

  const results = [];
  for (const tc of toolCallsList) {
    toolStatusText.textContent = `executing ${tc.name}...`;
    const output = await executeTool(tc.name, tc.arguments);
    results.push({ tool_call_id: tc.id, content: output });
    addToolResultBubble(tc.id, output);
  }

  // submit results to backend
  toolStatusText.textContent = 'submitting results...';
  await fetch(`${API}/threads/${currentThreadId}/tool_results`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tool_results: results })
  });

  // continue the conversation
  toolStatusText.textContent = 'continuing...';
  toolStatusEl.classList.remove('active');
  await streamChat(null);  // null message = continue without new user msg
}

// ── textarea auto-resize ───────────────────────────────────────────
document.getElementById('msgInput').addEventListener('input', function() {
  this.style.height = 'auto';
  this.style.height = Math.min(this.scrollHeight, 120) + 'px';
});

// ── init ───────────────────────────────────────────────────────────
loadThreads();
</script>
</body>
</html>
